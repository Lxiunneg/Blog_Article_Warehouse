---
title: 全球变暖【DFS】
date: 2023-03-31 21:43:56
tags: DFS
top: false
categories:
- 算法竞赛
---
# 全球变暖
题目地址：[全球变暖](https://www.lanqiao.cn/problems/178/learning/?contest_id=94)  
<!--more-->
## 题目描述
你有一张某海域 N × N 像素的照片，”.”表示海洋、”#”表示陆地，如下所示：  
```cpp
.......
.##....
.##....
....##.
..####.
...###.
.......
```

其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿，例如上图就有 2 座岛屿。  

由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。  

具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。  

例如上图中的海域未来会变成如下样子：
```cpp
.......
.......
.......
.......
....#..
.......
.......
```
## 输出格式
第一行包含一个整数N 。 N。N。  

以下 N  行 N  列，包含一个由字符”#”和”.”构成的 N × N  字符矩阵，代表一张海域照片，”#”表示陆地，”.”表示海洋   

照片保证第 1 行、第 1 列、第 N 行、第 N 列的像素都是海洋。  

## 输出格式
一个答案表示答案  

## 数据范围
**输入样例1：**  
```cpp
7
.......
.##....
.##....
....##.
..####.
...###.
.......
```

**输出样例1：**  
```
1
```

**输入样例2：**  
```cpp
9
.........
.##.##...
.#####...
.##.##...
.........
.##.#....
.#.###...
.#..#....
.........
```

**输出样例1：**  
```
1
```

## 分析
可以用DFS寻找岛屿的数量，并同时统计哪几块岛屿不会沉没。  

由题意得，岛屿不会沉没的条件为：**该岛屿中存在一块"#"它的上下左右都是"#"。**  
所以在遍历字符数组的时候除了坐标点(x,y)之外，还要再传入一个bool值f，当该岛屿中存在符合上述条件的"#"时，  
f = true，表示该岛最后不会沉没。

用Island存储原来岛的数量，只要在遍历的时候搜索到"#",便说明搜索到一块岛，Island+1。  
用Island_l存储海平面上升之后的岛的数量，只要在每次DFS结束的时候判断f == true,便说明搜索到有一块岛不会沉没，Island_l+1。  

**沉没的岛的数量 = 原来岛的数量 - 海平面上升之后的岛的数量 = Island - Island_l**  

- AC代码：
```cpp
#include <iostream>
using namespace std;
int Island = 0,Island_l = 0,n;
char Ocea[1005][1005];
bool vis[1005][1005] = {false};
int _x[4] = {1,-1,0,0};
int _y[4] = {0,0,1,-1};

void Init(){
    for(int i=0;i<=n+1;i++) Ocea[i][0] = '#';
    for(int i=0;i<=n+1;i++) Ocea[0][i] = '#';
    for(int i=0;i<=n+1;i++) Ocea[n+1][i] = '#';
    for(int i=0;i<=n+1;i++) Ocea[i][n+1] = '#';
}

void DFS(int x,int y,bool &f){
    if(Ocea[x][y] == '.' || vis[x][y]) return;
    else if(Ocea[x][y] == '#'){
        vis[x][y] = true;
        if(Ocea[x-1][y] == '#' && Ocea[x][y-1] == '#' && Ocea[x+1][y] =='#' && Ocea[x][y+1] == '#')
            f = true;
        for(int i=0;i<4;i++) DFS(x+_x[i],y+_y[i],f);
    }
    return;
}

int main(){
    cin >> n;
    Init();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            cin >> Ocea[i][j];
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            bool f = false;
            if(Ocea[i][j] == '#' && vis[i][j] == false){ 
                Island++;
                DFS(i,j,f);
            }
            if(f) Island_l++;
        }
    }
    cout << Island - Island_l << endl;
}
```

## 思考与感悟
Q:在DFS的时候如何**标记已经找过的坐标**？  
A:  
使用vis[N][N] bool二维数组 标记！**不要修改原地图！！！**  
确定规则：   
**false ---- 代表该点未被找到**    
**true ---- 代表该点已被找到**  

使用：  
在DFS递归中，只要找到符合点就标记vis[x][y] = true即可。  
