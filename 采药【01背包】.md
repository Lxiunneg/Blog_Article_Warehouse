---
title: 采药【动态规划】
date: 2023-04-02 21:24:35
tags: 
- 动态规划
- 模板题
categories:
- 算法竞赛
- 算法模板
mathjax: true
---
# [NOIP2005 普及组] 采药
题目地址：[[NOIP2005 普及组] 采药](https://www.luogu.com.cn/problem/P1048)  
## 题目描述

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”
<!--more-->  

如果你是辰辰，你能完成这个任务吗？

## 输入格式

第一行有 `2` 个整数 `T`（`1 <= T <= 1000`）和 `M`（`1 <=  M <= 100`），用一个空格隔开，`T` 代表总共能够用来采药的时间，`M` 代表山洞里的草药的数目。

接下来的 `M` 行每行包括两个在 `1` 到 `100` 之间（包括 `1` 和 `100`）的整数，分别表示采摘某株草药的时间和这株草药的价值。

## 输出格式

输出在规定的时间内可以采到的草药的最大总价值。

## 样例 #1

### 样例输入 #1

```
70 3
71 100
69 1
1 2
```

### 样例输出 #1

```
3
```

## 提示

**【数据范围】**

- 对于 `30%` 的数据，`M <= 10`；
- 对于全部的数据，`M <= 100`。

**【题目来源】**

NOIP 2005 普及组第三题

## 分析
这是一道01背包模版题  

设置一个dp二维数组,`dp[i][j]`表示在背包容量为j时，前i个物品所能装的最大价值  
递推公式： $ dp[i][j]$ $ = $ $ max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]) $  
$ dp[i-1][j] $ 表示在**没放`i`物品**之前，`j`容量背包所能装的最大价值,这个值来自上方  
$ dp[i-1][j-w[i]]+v[i] $ 表示在没放i物品之前，在所**能容纳`i`物品的背包**中的价值**加上`i`物品的价值，这个值来自左上方。


```cpp
#include <iostream>
#include <algorithm>
/*
该问题属于经典的01背包问题
该问题的特征：
在某个规定的条件下，使另一个条件价值最大，这两个条件强相关
*/
using namespace std;
//由于数据强相关，所以用结构体存储
struct Y{
	int t;
	int p;
}; 
//T是规定条件，M是物品的数量
int T,M;
/*
	dp数组的作用：
		dp[i][j]表示在将0～i物品装入背包后的最大价值

	注意：dp[0~M-1][0~T+1]
*/
int dp[101][1001] = {0};
Y y[101];
//背包问题需要初始化，需要将物品限制条件按升序排列，Cmp是结构体排序比较函数
bool Cmp(const Y& y1,const Y& y2){
	return y1.t < y2.t;
}
/*
	01背包问题的通用解法：
	1.设置dp二维数组
	2.按物品限制条件升序排列
	3.初始化dp
		-先全部初始化为0
		-初始化第0排（所有的dp数据从其上方和左上方推得），
		-在第1排开始递推
			dp[i][j] = max(d[i-1][j],dp[i-1][j-w[i]]+v[i]);
		d[i-1][j]:不放第i个物品
		dp[i-1][j-w[i]]+v[i]:放第i个物品
		注意要注意[j-w[i]]的边界问题，否则会使得数据错误
	4.dp[M-1][T]就是答案。
*/
int main(){
	ios::sync_with_stdio(false);
	
	cin >> T >> M;
	for(int i=0;i<M;i++) cin >> y[i].t >> y[i].p;
	sort(y,y+M,Cmp);//排序

	//初始化第0行
	for(int j=0;j<=T;j++)
		if(y[0].t <= j)//如果能够装下就装
			dp[0][j] = y[0].p;
	//开始递推
	for(int i=1;i<M;i++)//从第1行开始
		for(int j=1;j<=T;j++)//从有容量开始，到没有容量结束，即1～T，
		//所以 dp 数组为dp[0~M-1][0~T+1]
			if(j-y[i].t >= 0)//注意边界问题，否则会使数据错误
				dp[i][j] = max(dp[i-1][j],dp[i-1][j-y[i].t]+y[i].p);
			else//超出边界，就是装不下，直接不装
				dp[i][j] = dp[i-1][j];
	cout << dp[M-1][T];//输出答案
	return 0;
}

```

## 思考
模版题
[【B站代码随想录】](https://b23.tv/xNnG0PW)